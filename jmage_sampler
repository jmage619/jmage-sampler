#!/usr/bin/env python

import os
import os.path
import sys
import tty
import termios
import wave
import struct
import wx
import jmage.interface as jm
import jmage.ui
import jmage.util
import math

import ctypes
#from time import sleep
import time
from ctypes import pointer
from ctypes import byref
from ctypes import cast 
from ctypes import sizeof 

from ctypes import Union
from ctypes import Structure
from ctypes import POINTER
from ctypes import c_int
from ctypes import c_double
from ctypes import c_float
from ctypes import c_uint32
from ctypes import c_char
from ctypes import c_char_p
from ctypes import c_void_p
from ctypes import c_size_t

INT16_MAX = 2**16 / 2 - 1
PATH_MAX = 4096
SAMPLE_RATE = 44100
VOL_STEPS  = 17
NOTE_MIN = 0
NOTE_MAX = 127

OUT_LEN = 4.5

class JMSampler(Structure):
  pass

class jm_wave(Structure):
  _fields_ = [('wave', POINTER(c_float)),
    ('num_channels', c_int),
    ('length', c_int),
    ('left', c_int),
    ('right', c_int),
    ('has_loop', c_int)
  ]

# imitate getch in python
def getch():
  fd = sys.stdin.fileno()
  fd_flags = termios.tcgetattr(fd)
  tty.setraw(fd)
  key = sys.stdin.read(1)
  termios.tcsetattr(fd, termios.TCSADRAIN, fd_flags)
  return key

lib = ctypes.cdll.LoadLibrary('libjm_sampler.so')
lib.jm_parse_wave.argtypes = [POINTER(jm_wave), c_char_p]
lib.jm_destroy_wave.argtypes = [POINTER(jm_wave)]

ZONE_LIST = None
SAMPLER = None
# this caches loaded wav files
WAVES = {}
  
class LGPanel(jmage.ui.GridPanel):
  def __init__(self, font, char_width, *args, **kwargs):
    super(LGPanel, self).__init__(*args, **kwargs)
    self.font = font
    self.char_width = char_width

  def CreateHeader(self):
    header = self.NewHeader()
    st = wx.StaticText(header, label="Remove")
    header.Add(st)

    st = wx.StaticText(header, label="Name")
    st.SetSize((7 * self.char_width, -1))
    header.Add(st)

    return header

  def CreateRow(self):
    row = self.NewRow()
    # zone removal button
    remove_zone_button = wx.Button(row, -1, "-")
    row.Add(remove_zone_button)
    self.Bind(wx.EVT_BUTTON, self.OnZoneRemove, remove_zone_button)

    # name
    tc = wx.TextCtrl(row, style=wx.TE_PROCESS_ENTER)
    row.Add(tc)
    self.Bind(wx.EVT_TEXT_ENTER, self.OnControlEvent, tc)

    return row

  def UpdateRow(self, i, zone):
    windows = self.rows[i].GetWindows()
    windows[1].SetValue(zone.name)

  def OnZoneRemove(self, e):
    row = e.GetEventObject().GetParent()
    grid = self.GetParent()
    index = self.Index(row)
    grid.Remove(index)

  def OnControlEvent(self, e):
    win = e.GetEventObject()
    row = win.GetParent()
    row_index = self.Index(row)
    zone = ZONE_LIST[row_index]
    jm.zone_set_name(zone, win.GetValue())
    ZONE_LIST[row_index] = zone

class RGPanel(jmage.ui.GridPanel):
  def __init__(self, font, char_width, *args, **kwargs):
    super(RGPanel, self).__init__(*args, **kwargs)
    self.font = font
    self.char_width = char_width

  def CreateHeader(self):
    header = self.NewHeader()
    st = wx.StaticText(header, label="Vol (db)")
    st.SetSize((7 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Origin")
    st.SetSize((8 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Lower")
    st.SetSize((8 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Upper")
    st.SetSize((8 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Lo Vel")
    st.SetSize((5 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Hi Vel")
    st.SetSize((5 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Pitch")
    st.SetSize((5 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Start")
    st.SetSize((5 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Left")
    st.SetSize((5 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Right")
    st.SetSize((5 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Loop")
    st.SetSize((12 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="CF")
    st.SetSize((4 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Group")
    st.SetSize((8 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Off_Group")
    st.SetSize((9 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Attack")
    #st.SetSize((5 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Hold")
    st.SetSize((5 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Decay")
    #st.SetSize((5 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Sustain")
    #st.SetSize((5 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Release")
    #st.SetSize((5 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="20s_Tail")
    st.SetSize((7 * self.char_width, -1))
    header.Add(st)

    st = wx.StaticText(header, label="Path")
    st.SetSize((64 * self.char_width, -1))
    header.Add(st)

    return header

  def CreateRow(self):
    row = self.NewRow()

    # vol
    tc = jmage.ui.DragBox(row, steps=151, min=-144, max=6,
      callback=self.ControlCallback, style=wx.TE_RIGHT)
    tc.SetFont(self.font)
    row.Add(tc)

    # origin
    cb = jmage.ui.NoteChoice(row)
    cb.SetFont(self.font)
    row.Add(cb)
    self.Bind(wx.EVT_CHOICE, self.OnControlEvent, cb)

    # lower
    cb = jmage.ui.NoteChoice(row)
    cb.SetFont(self.font)
    row.Add(cb)
    self.Bind(wx.EVT_CHOICE, self.OnControlEvent, cb)

    # upper
    cb = jmage.ui.NoteChoice(row)
    cb.SetFont(self.font)
    row.Add(cb)
    self.Bind(wx.EVT_CHOICE, self.OnControlEvent, cb)

    # lo vel
    tc = jmage.ui.DragBox(row, steps=128, min=0, max=127,
      callback=self.ControlCallback, style=wx.TE_RIGHT)
    tc.SetFont(self.font)
    row.Add(tc)

    # hi vel
    tc = jmage.ui.DragBox(row, steps=128, min=0, max=127,
      callback=self.ControlCallback, style=wx.TE_RIGHT)
    tc.SetFont(self.font)
    row.Add(tc)

    # pitch
    tc = jmage.ui.DragBox(row, min=-0.5, max=0.5,
      fmt="%.2f", callback=self.ControlCallback, style=wx.TE_RIGHT)
    tc.SetFont(self.font)
    row.Add(tc)

    # start
    tc = jmage.ui.DragBox(row, min=0.0,
      fmt="%.2f", callback=self.ControlCallback, style=wx.TE_RIGHT)
    tc.SetFont(self.font)
    row.Add(tc)

    # left
    tc = jmage.ui.DragBox(row, min=0.0,
      fmt="%.2f", callback=self.ControlCallback, style=wx.TE_RIGHT)
    tc.SetFont(self.font)
    row.Add(tc)

    # right
    tc = jmage.ui.DragBox(row, min=0.0,
      fmt="%.2f", callback=self.ControlCallback, style=wx.TE_RIGHT)
    tc.SetFont(self.font)
    row.Add(tc)

    # loop
    choice = wx.Choice(row, choices=['off', 'on', 'one shot'])
    row.Add(choice)
    self.Bind(wx.EVT_CHOICE, self.OnControlEvent, choice)

    # cf
    tc = jmage.ui.DragBox(row, min=0, max=1000,
      callback=self.ControlCallback, style=wx.TE_RIGHT)
    tc.SetFont(self.font)
    row.Add(tc)

    choice_arr = ['none']

    for i in range(1,17):
      choice_arr.append("%s" % i)

    # group
    choice = wx.Choice(row, choices=choice_arr)
    row.Add(choice)
    self.Bind(wx.EVT_CHOICE, self.OnControlEvent, choice)

    # off group
    choice = wx.Choice(row, choices=choice_arr)
    row.Add(choice)
    self.Bind(wx.EVT_CHOICE, self.OnControlEvent, choice)

    # attack
    tc = jmage.ui.DragBox(row, min=0.0, max=2.0,
      fmt="%.2f", callback=self.ControlCallback, style=wx.TE_RIGHT)
    tc.SetFont(self.font)
    row.Add(tc)

    # hold
    tc = jmage.ui.DragBox(row, min=0.0, max=2.0,
      fmt="%.2f", callback=self.ControlCallback, style=wx.TE_RIGHT)
    tc.SetFont(self.font)
    row.Add(tc)

    # decay
    tc = jmage.ui.DragBox(row, min=0.0, max=2.0,
    #tc = jmage.ui.DragBox(row, min=0.0, max=20.0,
      fmt="%.2f", callback=self.ControlCallback, style=wx.TE_RIGHT)
    tc.SetFont(self.font)
    row.Add(tc)

    # sustain
    tc = jmage.ui.DragBox(row, min=0.0, max=1.0,
      fmt="%.2f", callback=self.ControlCallback, style=wx.TE_RIGHT)
    tc.SetFont(self.font)
    row.Add(tc)

    # release
    tc = jmage.ui.DragBox(row, min=0.0, max=2.0,
    #tc = jmage.ui.DragBox(row, min=0.0, max=20.0,
      fmt="%.2f", callback=self.ControlCallback, style=wx.TE_RIGHT)
    tc.SetFont(self.font)
    row.Add(tc)

    # tail
    cb = wx.CheckBox(row)
    row.Add(cb)
    self.Bind(wx.EVT_CHECKBOX, self.OnControlEvent, cb)

    # path
    st = wx.StaticText(row)
    row.Add(st)

    return row

  def SetLongTail(self, row, on=True):
    windows = row.GetWindows()
    if on == True:
      # increase decay and release
      windows[16].max = 20.0
      windows[18].max = 20.0
    else:
      windows[16].max = 2.0
      windows[18].max = 2.0

  def UpdateRow(self, i, zone):
    windows = self.rows[i].GetWindows()
    # vol
    windows[0].ChangeValue(20. * math.log(zone.amp, 10.))
    # origin
    windows[1].Select(zone.origin)
    # lower
    windows[2].Select(zone.low_key)
    # upper
    windows[3].Select(zone.high_key)
    # lo vel
    windows[4].ChangeValue(zone.low_vel)
    # hi vel
    windows[5].ChangeValue(zone.high_vel)
    # pitch
    windows[6].ChangeValue(zone.pitch_corr)
    # zone.right makes no sense it can be changed by user
    # this should be revisited anyway is there a better way to define
    # max time values?
    #wav_end = float(zone.right) / SAMPLE_RATE
    wav_end = float(zone.wave_length) / SAMPLE_RATE
    # start
    windows[7].max = wav_end
    windows[7].ChangeValue(float(zone.start) / SAMPLE_RATE)
    # left
    windows[8].max = wav_end
    windows[8].ChangeValue(float(zone.left) / SAMPLE_RATE)
    # right
    windows[9].max = wav_end
    windows[9].ChangeValue(float(zone.right) / SAMPLE_RATE)
    # loop
    windows[10].Select(zone.mode)
    # cf
    windows[11].ChangeValue(int(float(zone.crossfade) / SAMPLE_RATE * 1000))
    # group
    windows[12].Select(zone.group)
    # off group
    windows[13].Select(zone.off_group)
    # attack
    windows[14].ChangeValue(float(zone.attack) / SAMPLE_RATE)
    # hold
    windows[15].ChangeValue(float(zone.hold) / SAMPLE_RATE)

    # ensure long tail is set before setting decay and release
    if zone.long_tail:
      self.SetLongTail(self.rows[i])
    else:
      self.SetLongTail(self.rows[i], False)

    # decay
    windows[16].ChangeValue(float(zone.decay) / SAMPLE_RATE)
    # sustain
    windows[17].ChangeValue(zone.sustain)
    # release
    windows[18].ChangeValue(float(zone.release) / SAMPLE_RATE)
    # tail
    windows[19].SetValue(zone.long_tail)


    # path
    windows[20].SetLabel(zone.path)

  def ControlCallback(self, win):
    #print "callback called"
    row = win.GetParent()
    row_index = self.Index(row)
    zone = ZONE_LIST[row_index]

    col_index = row.Index(win)

    # vol
    if col_index == 0:
      zone.amp = 10.**(win.GetValue() / 20.)
    # origin
    elif col_index == 1:
      zone.origin = win.GetSelection()
    # lower
    elif col_index == 2:
      zone.low_key = win.GetSelection()
    # upper
    elif col_index == 3:
      zone.high_key = win.GetSelection()
    # lo vel
    elif col_index == 4:
      zone.low_vel = int(win.GetValue())
    # hi vel
    elif col_index == 5:
      zone.high_vel = int(win.GetValue())
    # pitch
    elif col_index == 6:
      zone.pitch_corr = win.GetValue()
    # start
    elif col_index == 7:
      zone.start = int(SAMPLE_RATE * win.GetValue())
    # left
    elif col_index == 8:
      zone.left = int(SAMPLE_RATE * win.GetValue())
    # right
    elif col_index == 9:
      zone.right = int(SAMPLE_RATE * win.GetValue())
    # loop
    elif col_index == 10:
      zone.mode = win.GetSelection()
    # cf
    elif col_index == 11:
      zone.crossfade = int(SAMPLE_RATE * win.GetValue() / 1000.)
    # group
    elif col_index == 12:
      zone.group = win.GetSelection()
    # off group
    elif col_index == 13:
      zone.off_group = win.GetSelection()
    # attack
    elif col_index == 14:
      zone.attack = int(SAMPLE_RATE * win.GetValue())
    # hold
    elif col_index == 15:
      zone.hold = int(SAMPLE_RATE * win.GetValue())
    # decay
    elif col_index == 16:
      zone.decay = int(SAMPLE_RATE * win.GetValue())
    # sustain
    if col_index == 17:
      zone.sustain = win.GetValue()
    # release
    elif col_index == 18:
      zone.release = int(SAMPLE_RATE * win.GetValue())
    # tail
    elif col_index == 19:
      zone.long_tail = win.GetValue()
      if zone.long_tail:
        self.SetLongTail(row)
      else:
        self.SetLongTail(row, False)

    ZONE_LIST[row_index] = zone

  def OnControlEvent(self, e):
    self.ControlCallback(e.GetEventObject())

class MyFrame(wx.Frame):
  def __init__(self, *args, **kwargs):
    super(MyFrame, self).__init__(*args, **kwargs)

    # always increment on zone creation
    self.zone_name_index = 1
    self.SetTitle("Ghetto Sampler")

    # create menu bar and File menu with exit item
    menubar = wx.MenuBar()
    file_menu = wx.Menu()
    item = file_menu.Append(wx.ID_EXIT, 'Quit', 'Quit application')
    self.Bind(wx.EVT_MENU, self.OnQuit, item)
    menubar.Append(file_menu, '&File')
    self.SetMenuBar(menubar)

    sp = wx.SplitterWindow(self, style=wx.SP_LIVE_UPDATE)
    self.panel1 = wx.Panel(sp)

    # create Volume label
    vbox = wx.BoxSizer(wx.VERTICAL)
    st1 = wx.StaticText(self.panel1, label='Volume:')
    vbox.Add(st1, flag=wx.LEFT | wx.TOP, border=10)

    # horizontal sizer to contain volume control
    hbox1 = wx.BoxSizer(wx.HORIZONTAL)

    # set font and extract char width to use in Volume output box
    self.font = wx.Font(10, wx.TELETYPE, wx.NORMAL, wx.NORMAL)
    dc = wx.ClientDC(self.panel1)
    dc.SetFont(self.font)
    self.char_width = dc.GetTextExtent("X")[0]
    width = int(self.char_width * OUT_LEN + 0.5)

    # create Volume output box
    self.output = wx.TextCtrl(self.panel1, size=(width, -1),
      style=wx.TE_RIGHT | wx.TE_PROCESS_ENTER)
    self.output.SetValue(str(VOL_STEPS - 1))
    self.output.SetFont(self.font)
    self.Bind(wx.EVT_TEXT_ENTER, self.OnVolUpdate, self.output)
    hbox1.Add(self.output, flag=wx.ALIGN_CENTER | wx.RIGHT, border=10)

    # create Volume slider
    self.slider = wx.Slider(self.panel1, -1, VOL_STEPS - 1, 0, VOL_STEPS - 1, size=(200, -1),
      style=wx.SL_HORIZONTAL)
    self.Bind(wx.EVT_SCROLL, self.OnVolScroll, self.slider)
    hbox1.Add(self.slider, flag=wx.ALIGN_CENTER | wx.RIGHT, border=10)
    
    # to load patches
    button = wx.Button(self.panel1, -1, "save")
    self.Bind(wx.EVT_BUTTON, self.OnSave, button)
    hbox1.Add(button, flag=wx.ALIGN_CENTER | wx.RIGHT, border=10)
    button = wx.Button(self.panel1, -1, "load")
    self.Bind(wx.EVT_BUTTON, self.OnLoad, button)
    hbox1.Add(button, flag=wx.ALIGN_CENTER)

    vbox.Add(hbox1, flag=wx.LEFT | wx.TOP, border=10)

    # create zone grid

    # use output box to set row height, add 7 pixel border
    row_height = self.output.GetSize().height + 7

    self.zone_grid = jmage.ui.Grid(self.panel1, row_height=row_height, style=wx.TAB_TRAVERSAL)
    grid_panel = LGPanel(self.font, self.char_width, self.zone_grid)
    self.zone_grid.Add(grid_panel)
    grid_panel = RGPanel(self.font, self.char_width, self.zone_grid)
    self.zone_grid.Add(grid_panel)
    self.zone_grid.AddHeader()
    self.zone_grid.RegisterData(ZONE_LIST)

    vbox.Add(self.zone_grid, flag=wx.EXPAND | wx.LEFT | wx.TOP, border=10, proportion=1)
    self.panel1.SetSizer(vbox)

    self.panel2 = wx.Panel(sp)
    # to create zones
    self.add_zone_button = wx.Button(self.panel2, -1, "+")

    self.Bind(wx.EVT_BUTTON, self.OnZoneAdd, self.add_zone_button)

    sp.SplitHorizontally(self.panel1, self.panel2, sashPosition=250)

    self.Show()

  def OnQuit(self, e):
    self.Close()

  def OnVolScroll(self, e):
    level = e.GetEventObject().GetValue()
    msg = jm.msg()
    msg.type = jm.MT_VOLUME
    msg.data.i = level
    SAMPLER.send_msg(msg)

    self.output.SetValue(str(level))

  def OnVolUpdate(self, e):
    val = e.GetEventObject().GetValue()
    try:
      level = int(val)
      if level >= 0 and level < VOL_STEPS:
        msg = jm.msg()
        msg.type = jm.MT_VOLUME
        msg.data.i = level
        SAMPLER.send_msg(msg)
        self.slider.SetValue(level)
    except ValueError:
      pass

  def OnSave(self, e):
    dlg = wx.FileDialog(self, "Save a FUCKING patch already!!", os.getcwd(), style=wx.SAVE)
    if dlg.ShowModal() == wx.ID_OK:
      path = dlg.GetPath()
      print path

      # probably want to handle case where not sfz or jmz
      if path.endswith('.sfz'):
        patch = jmage.util.SFZ()
      elif path.endswith('.jmz'):
        patch = jmage.util.JMZ()

      for zone in ZONE_LIST:
        region = {}
        if path.endswith('.jmz'):
          region['jm_name'] = zone.name
        region['volume'] = 20. * math.log(zone.amp, 10.)
        region['sample'] = os.path.basename(zone.path)
        region['lokey'] = zone.low_key
        region['hikey'] = zone.high_key
        region['pitch_keycenter'] = zone.origin
        region['lovel'] = zone.low_vel
        region['hivel'] = zone.high_vel
        # 0.05 epsilon to prevent truncation error
        region['tune'] = int(zone.pitch_corr * 100. + 0.05)
        region['offset'] = zone.start
        if zone.mode == jm.LOOP_OFF:
          region['loop_mode'] = 'no_loop'
        elif zone.mode == jm.LOOP_CONTINUOUS:
          region['loop_mode'] = 'loop_continuous'
        else:
          region['loop_mode'] = 'one_shot'
        region['loop_start'] = zone.left
        region['loop_end'] = zone.right
        region['loop_crossfade'] = float(zone.crossfade) / SAMPLE_RATE
        region['ampeg_attack'] = float(zone.attack) / SAMPLE_RATE
        region['ampeg_hold'] = float(zone.hold) / SAMPLE_RATE
        region['ampeg_decay'] = float(zone.decay) / SAMPLE_RATE
        region['ampeg_sustain'] = zone.sustain * 100.
        region['ampeg_release'] = float(zone.release) / SAMPLE_RATE
        patch.add_region(region)

      #patch.write(sys.stdout)
      f = open(path, 'w')
      patch.write(f)
      f.close()

    dlg.Destroy()

  def NameZone(self, zone):
    jm.zone_set_name(zone, "Zone %i" % self.zone_name_index)
    self.zone_name_index += 1

  def OnLoad(self, e):
    dlg = wx.FileDialog(self, "Open a FUCKING patch already!!", os.getcwd(), style=wx.OPEN)
    if dlg.ShowModal() == wx.ID_OK:
      path = dlg.GetPath()
      # probably want to handle case where not sfz or jmz
      if path.endswith('.sfz'):
        patch = jmage.util.parse_sfz(path)
      elif path.endswith('.jmz'):
        patch = jmage.util.parse_jmz(path)
      #print patch.regions
      patch_dir = os.path.dirname(path)

      t = time.time()
      for region in patch.regions:
        wav_path = os.path.join(patch_dir, region['sample'])
        zone = new_zone_from_file(wav_path)
        if path.endswith('.jmz'):
          jm.zone_set_name(zone, region['jm_name']) 
        else:
          self.NameZone(zone)
        # these should really be already validated and converted inside parse
        zone.amp = 10.**(region['volume'] / 20.)
        zone.low_key = region['lokey']
        zone.high_key = region['hikey']
        zone.origin = region['pitch_keycenter']
        zone.low_vel = region['lovel']
        zone.high_vel = region['hivel']
        zone.pitch_corr = region['tune'] / 100.
        zone.start = region['offset']
        # loop_mode, start, and end do not have defaults, may be defined inside wav
        if 'loop_mode' in region:
          if region['loop_mode'] == 'loop_continuous':
            zone.mode = jm.LOOP_CONTINUOUS
          elif region['loop_mode'] == 'no_loop':
            zone.mode = jm.LOOP_OFF
          elif region['loop_mode'] == 'one_shot':
            zone.mode = jm.LOOP_ONE_SHOT
        if 'loop_start' in region:
          zone.left = region['loop_start']
        if 'loop_end' in region:
          zone.right = region['loop_end']
        zone.crossfade = int(SAMPLE_RATE * region['loop_crossfade'])
        zone.attack = int(SAMPLE_RATE * region['ampeg_attack'])
        zone.hold = int(SAMPLE_RATE * region['ampeg_hold'])
        zone.decay = int(SAMPLE_RATE * region['ampeg_decay'])
        zone.sustain = region['ampeg_sustain'] / 100.
        zone.release = int(SAMPLE_RATE * region['ampeg_release'])

        # default to long tail on if patch has long decay or release
        if zone.decay >= 20.0 * SAMPLE_RATE or zone.release >= 20.0 * SAMPLE_RATE:
          zone.long_tail = True

        self.zone_grid.Append(zone)
      print "time to load patch: %f\n" % (time.time() - t)

    dlg.Destroy()

  def OnZoneAdd(self, e):
    dlg = wx.FileDialog(self, "Open a FUCKING WAV already!!", os.getcwd(), style=wx.OPEN)
    if dlg.ShowModal() == wx.ID_OK:
      path = dlg.GetPath()

      zone = new_zone_from_file(path)
      self.NameZone(zone)
      self.zone_grid.Append(zone)

    dlg.Destroy()

  def OnZoneRemove(self, e):
    win = e.GetEventObject()
    grid = win.GetParent()
    index = grid.GetIndex(win)

    # first index of grid is header
    zone_index = index[0] - 1
    lib.jm_remove_zone(SAMPLER, zone_index)
    grid.RemoveRow(index[0])

def load_wave(path):
  wav = jm_wave()
  lib.jm_parse_wave(byref(wav), path)
  return wav

def new_zone_from_file(path):
  if path in WAVES:
    wav = WAVES[path]
  else:
    wav = load_wave(path)
    WAVES[path] = wav

  zone = jm.key_zone()
  jm.init_key_zone(zone)

  jm.zone_set_path(zone, path)
  zone.num_channels = wav.num_channels
  zone.wave = wav.wave

  zone.wave_length = wav.length
  zone.left = wav.left
  zone.right = wav.right
  print "new zone loop on?", wav.has_loop
  if wav.has_loop:
    zone.mode = jm.LOOP_CONTINUOUS

  return zone

if __name__ == '__main__':
  ZONE_LIST = jm.ZoneList()
  SAMPLER = jm.Sampler(ZONE_LIST)

  level = VOL_STEPS - 1

  msg = jm.msg()
  msg.type = jm.MT_VOLUME
  
  msg.data.i = level
  SAMPLER.send_msg(msg)

  app = wx.App()

  frame = MyFrame(None, size=(490,400))

  app.MainLoop()
  SAMPLER.destroy()
  ZONE_LIST.destroy()

  for wav in WAVES:
    lib.jm_destroy_wave(byref(WAVES[wav]))
