#!/usr/bin/env python

import sys
import tty
import termios
import wave
import struct
import wx

import ctypes
from time import sleep
from ctypes import pointer
from ctypes import byref
from ctypes import cast 
from ctypes import sizeof 

from ctypes import Union
from ctypes import Structure
from ctypes import POINTER
from ctypes import c_int
from ctypes import c_double
from ctypes import c_float
from ctypes import c_uint32
from ctypes import c_void_p
from ctypes import c_size_t

INT16_MAX = 2**16 / 2 - 1
INT_MAX = 2**32 / 2 - 1
INT_MIN  = - INT_MAX - 1
RELEASE_TIME  = 44100 / 1000.
MT_VOLUME = 0
VOL_STEPS  = 17

OUT_LEN = 4.5

class JMSampler(Structure):
  pass

class jm_key_zone(Structure):
  _fields_ = [('wave', (POINTER(c_float) * 2)),
    ('wave_length', c_uint32),
    ('start', c_uint32),
    ('left', c_uint32),
    ('right', c_uint32),
    ('lower_bound', c_int),
    ('upper_bound', c_int),
    ('origin', c_int),
    ('amp', c_double),
    ('rel_time', c_double),
    ('pitch_corr', c_double),
    ('loop_on', c_int),
    ('crossfade', c_uint32)
  ]


class jm_msg_data(Union):
  _fields_ = [('i', c_int)]

class jm_msg(Structure):
  _fields_ = [('type', c_int), ('data', jm_msg_data)]

# imitate getch in python
def getch():
  fd = sys.stdin.fileno()
  fd_flags = termios.tcgetattr(fd)
  tty.setraw(fd)
  key = sys.stdin.read(1)
  termios.tcsetattr(fd, termios.TCSADRAIN, fd_flags)
  return key

lib = ctypes.cdll.LoadLibrary('libjm_sampler.so')
lib.jm_init_key_zone.argtypes = [POINTER(jm_key_zone)]
lib.jm_new_sampler.restype = POINTER(JMSampler)
lib.jm_destroy_sampler.argtypes = [POINTER(JMSampler)]
lib.jm_add_zone.argtypes = [POINTER(JMSampler), c_int, POINTER(jm_key_zone)]
lib.jm_remove_zone.argtypes = [POINTER(JMSampler), c_int]
lib.jm_new_msg.argtypes = [POINTER(JMSampler)]
lib.jm_new_msg.restype = POINTER(jm_msg)
lib.jm_send_msg.argtypes = [POINTER(JMSampler), POINTER(jm_msg)]
lib.jm_receive_msg.argtypes = [POINTER(JMSampler), POINTER(POINTER(jm_msg))]
lib.jm_receive_msg.restype = c_int

SAMPLER = None
  
class MyFrame(wx.Frame):
  def __init__(self, *args, **kwargs):
    super(MyFrame, self).__init__(*args, **kwargs)

    self.SetTitle("Ghetto Sampler")

    # create menu bar and File menu with exit item
    menubar = wx.MenuBar()
    file_menu = wx.Menu()
    item = file_menu.Append(wx.ID_EXIT, 'Quit', 'Quit application')
    self.Bind(wx.EVT_MENU, self.OnQuit, item)
    menubar.Append(file_menu, '&File')
    self.SetMenuBar(menubar)

    panel = wx.Panel(self)

    # create Volume label
    vbox = wx.BoxSizer(wx.VERTICAL)
    st1 = wx.StaticText(panel, label='Volume:')
    vbox.Add(st1, flag=wx.LEFT | wx.RIGHT | wx.TOP, border=10)

    # horizontal sizer to contain volume control
    hbox1 = wx.BoxSizer(wx.HORIZONTAL)

    # set font and extract char width to use in Volume output box
    font = wx.Font(10, wx.TELETYPE, wx.NORMAL, wx.NORMAL)
    dc = wx.ClientDC(panel)
    dc.SetFont(font)
    char_width = dc.GetTextExtent("X")[0]
    width = int(char_width * OUT_LEN + 0.5)

    # create Volume output box
    self.output = wx.TextCtrl(panel, size=(width, -1),
      style=wx.TE_RIGHT | wx.TE_PROCESS_ENTER)
    self.output.SetValue(str(VOL_STEPS - 1))
    self.output.SetFont(font)
    self.Bind(wx.EVT_TEXT_ENTER, self.OnVolUpdate, self.output)
    hbox1.Add(self.output, flag=wx.RIGHT, border=10)

    # create Volume slider
    self.slider = wx.Slider(panel, -1, VOL_STEPS - 1, 0, VOL_STEPS - 1, size=(200, -1),
      style=wx.SL_HORIZONTAL)
    self.Bind(wx.EVT_SCROLL, self.OnVolScroll, self.slider)
    hbox1.Add(self.slider, flag=wx.ALIGN_CENTER)

    vbox.Add(hbox1, flag=wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, border=10)

    panel.SetSizer(vbox)

    self.Show()

  def OnQuit(self, e):
    self.Close()

  def OnVolScroll(self, e):
    level = e.GetEventObject().GetValue()
    msg = lib.jm_new_msg(SAMPLER)
    msg.contents.type = MT_VOLUME
    msg.contents.data.i = level
    lib.jm_send_msg(SAMPLER, msg)

    self.output.SetValue(str(level))

  def OnVolUpdate(self, e):
    val = e.GetEventObject().GetValue()
    try:
      level = int(val)
      if level >= 0 and level < VOL_STEPS:
        msg = lib.jm_new_msg(SAMPLER)
        msg.contents.type = MT_VOLUME
        msg.contents.data.i = level
        lib.jm_send_msg(SAMPLER, msg)
        self.slider.SetValue(level)
    except ValueError:
      pass

if __name__ == '__main__':
  #global CLIENT
  zone = jm_key_zone()
  lib.jm_init_key_zone(byref(zone))
  wav_file = wave.open('afx.wav')

  wave_length = wav_file.getnframes()

  wave = []
  wave.append(((c_float * wave_length))())
  wave.append(((c_float * wave_length))())

  for i in range(wave_length):
    frame = struct.unpack('<hh', wav_file.readframes(1))
    wave[0][i] = frame[0] / float(INT16_MAX)
    wave[1][i] = frame[1] / float(INT16_MAX)

  wav_file.close()

  zone.wave[0] = wave[0]
  zone.wave[1] = wave[1]

  zone.origin = 48
  zone.lower_bound = INT_MIN
  zone.upper_bound = INT_MAX
  zone.rel_time = RELEASE_TIME
  zone.start = 0
  zone.left = 44100
  zone.right = 3 * 44100 + 5 * 44100 / 8
  zone.wave_length = wave_length
  zone.amp = 1.0
  zone.pitch_corr = 0.0
  zone.loop_on = 1
  zone.crossfade = 22050

  #print JM_ZONES.contents.wave[0][0]

  SAMPLER = lib.jm_new_sampler()

  lib.jm_add_zone(SAMPLER, 0, byref(zone))

  #level = VOL_STEPS - 16 
  level = VOL_STEPS - 1

  msg = lib.jm_new_msg(SAMPLER)
  msg.contents.type = MT_VOLUME
  
  msg.contents.data.i = level
  lib.jm_send_msg(SAMPLER, msg)

  app = wx.App()

  MyFrame(None)

  app.MainLoop()
  lib.jm_remove_zone(SAMPLER, 0)
  lib.jm_destroy_sampler(SAMPLER)
